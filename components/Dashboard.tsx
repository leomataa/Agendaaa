
import React, { useMemo } from 'react';
import { Appointment, Product, Transaction, Notification, NotificationType, Client, Payable, Service } from '../types';
import { format } from 'date-fns/format';
import { parseISO } from 'date-fns/parseISO';
import { differenceInDays } from 'date-fns/differenceInDays';
import { isTomorrow } from 'date-fns/isTomorrow';
import { isAfter } from 'date-fns/isAfter';
import { formatISO } from 'date-fns/formatISO';
import { BellIcon } from './Icons';

interface DashboardProps {
  appointments: Appointment[];
  transactions: Transaction[];
  products: Product[];
  clients: Client[];
  payables: Payable[];
}

const getNotificationMessage = (notification: Notification, appointments: Appointment[], products: Product[], payables: Payable[]): string => {
    const { type, relatedId } = notification;
    switch (type) {
        case NotificationType.UPCOMING_APPOINTMENT:
            const apt = appointments.find(a => a.id === relatedId);
            return `Lembrete: Atendimento de ${apt?.clientName} amanhã (${(apt?.services || []).map(s => s.name).join(', ')}).`;
        case NotificationType.FEEDBACK_REQUEST:
             const feedbackApt = appointments.find(a => a.id === relatedId);
            return `Enviar avaliação para ${feedbackApt?.clientName} (atendimento de 7 dias atrás).`;
        case NotificationType.FOLLOW_UP:
            const followUpApt = appointments.find(a => a.id === relatedId);
            return `Sugerir retorno para ${followUpApt?.clientName} (última visita há 30+ dias).`;
        case NotificationType.LOW_STOCK:
            const product = products.find(p => p.id === relatedId);
            return `Estoque baixo: ${product?.name} (${product?.quantity} restantes).`;
        case NotificationType.UPCOMING_EXPENSE:
            const payable = payables.find(p => p.id === relatedId);
            return `Lembrete de Pagamento: ${payable?.description} vence amanhã.`;
        default:
            return "Notificação desconhecida.";
    }
}


const Dashboard: React.FC<DashboardProps> = ({ appointments, transactions, products, clients, payables }) => {

  const notifications = useMemo(() => {
    const now = new Date();
    const generated: Notification[] = [];

    // 1. Upcoming appointment reminders (1 day before)
    appointments.forEach(apt => {
      if (isTomorrow(parseISO(apt.date))) {
        generated.push({
          id: `notif-apt-${apt.id}`,
          type: NotificationType.UPCOMING_APPOINTMENT,
          message: '', // Will be generated by getNotificationMessage
          date: apt.date,
          relatedId: apt.id
        });
      }
    });

    // 2. Feedback request (7 days after)
    appointments.forEach(apt => {
        const aptDate = parseISO(apt.date);
        if (differenceInDays(now, aptDate) === 7 && isAfter(now, aptDate)) {
             generated.push({
                id: `notif-feedback-${apt.id}`,
                type: NotificationType.FEEDBACK_REQUEST,
                message: '',
                date: apt.date,
                relatedId: apt.id,
            });
        }
    });

    // 3. Follow-up reminder (30+ days after last visit)
    clients.forEach(client => {
        const lastVisitDate = parseISO(client.lastVisit);
        if (differenceInDays(now, lastVisitDate) >= 30) {
            const lastAppointment = appointments.find(a => a.clientId === client.id && a.date === client.lastVisit);
            if(lastAppointment) {
                generated.push({
                    id: `notif-followup-${client.id}`,
                    type: NotificationType.FOLLOW_UP,
                    message: '',
                    date: client.lastVisit,
                    relatedId: lastAppointment.id,
                });
            }
        }
    });

    // 4. Low stock warnings
    products.forEach(prod => {
      if (prod.quantity <= prod.lowStockThreshold) {
        generated.push({
          id: `notif-stock-${prod.id}`,
          type: NotificationType.LOW_STOCK,
          message: '',
          date: formatISO(now),
          relatedId: prod.id,
        });
      }
    });

    // 5. Upcoming expense reminders
    payables.forEach(payable => {
        if (!payable.isPaid && isTomorrow(parseISO(payable.dueDate))) {
            generated.push({
                id: `notif-payable-${payable.id}`,
                type: NotificationType.UPCOMING_EXPENSE,
                message: '',
                date: payable.dueDate,
                relatedId: payable.id
            });
        }
    });

    return generated.sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime());
  }, [appointments, products, clients, payables]);

  const todayAppointments = appointments.filter(apt => format(parseISO(apt.date), 'yyyy-MM-dd') === format(new Date(), 'yyyy-MM-dd'));
  const monthlyRevenue = transactions
    .filter(t => t.type === 'income' && format(parseISO(t.date), 'yyyy-MM') === format(new Date(), 'yyyy-MM'))
    .reduce((sum, t) => sum + t.amount, 0);

  const StatCard: React.FC<{ title: string; value: string | number; color: string }> = ({ title, value, color }) => (
    <div className={`bg-white p-6 rounded-lg shadow-md border-l-4 ${color}`}>
      <h3 className="text-sm font-medium text-gray-500">{title}</h3>
      <p className="mt-2 text-3xl font-bold text-gray-900">{value}</p>
    </div>
  );

  return (
    <div className="p-8 bg-gray-50 flex-1">
      <h1 className="text-3xl font-bold text-gray-800">Dashboard</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
        <StatCard title="Atendimentos Hoje" value={todayAppointments.length} color="border-teal-500" />
        <StatCard title="Receita do Mês" value={`R$ ${monthlyRevenue.toFixed(2)}`} color="border-blue-500" />
        <StatCard title="Alertas de Estoque" value={products.filter(p => p.quantity <= p.lowStockThreshold).length} color="border-red-500" />
      </div>

      <div className="mt-10 bg-white p-6 rounded-lg shadow-md">
        <h2 className="text-xl font-semibold text-gray-800 flex items-center">
            <BellIcon className="h-6 w-6 mr-3 text-yellow-500"/>
            Notificações Importantes
        </h2>
        <div className="mt-4 space-y-4">
            {notifications.length > 0 ? (
                notifications.map(notif => (
                    <div key={notif.id} className="flex items-start p-4 bg-gray-50 rounded-md border border-gray-200">
                        <div className={`h-2 w-2 rounded-full mt-1.5 ${
                            notif.type === NotificationType.LOW_STOCK || notif.type === NotificationType.UPCOMING_EXPENSE ? 'bg-red-500' : 
                            notif.type === NotificationType.UPCOMING_APPOINTMENT ? 'bg-blue-500' : 
                            'bg-yellow-500'
                        }`}></div>
                        <div className="ml-4">
                            <p className="text-sm text-gray-700">{getNotificationMessage(notif, appointments, products, payables)}</p>
                            <p className="text-xs text-gray-500">{format(parseISO(notif.date), "dd/MM/yyyy")}</p>
                        </div>
                    </div>
                ))
            ) : (
                <p className="text-gray-500 text-center py-4">Nenhuma notificação no momento.</p>
            )}
        </div>
      </div>
    </div>
  );
};

export default Dashboard;